<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Crypto Dashboard</title>

  <!-- GridStack -->
  <link href="https://cdn.jsdelivr.net/npm/gridstack@9.2.1/dist/gridstack.min.css" rel="stylesheet"/>
  <script src="https://cdn.jsdelivr.net/npm/gridstack@9.2.1/dist/gridstack-all.js"></script>

  <!-- DataTables -->
  <link href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css" rel="stylesheet"/>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
    <!-- PLOT -->

  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>

  <link rel="stylesheet" href="/static/css/styles.css"> 
   <script src="/static/indicators.js"></script>

</head>

<body>

 <!-- ðŸ”· Barra titolo -->
<div class="header">
    <div class="header-title">ðŸ“ˆ Crypto Live</div>
    <div class="header-status">
      Ultimo aggiornamento:
      <span id="heartbeatLabel">â€”</span>
    </div>
</div>

<button onclick="addTopVolume()">âž• Top Volume</button>
<button onclick="addOHLC()">âž• OHLC Table</button>
<button onclick="addCandleChart()">âž• Candlestick</button>
<button onclick="layout_addWidget({'type':'chart','pair': 'BTC/USDC', 'timeframe':'1m'})">âž• BTC 1m</button>

<div class="grid-stack"></div>


<!-------------------------------------------->
<script>

const heartbeatLabel = document.getElementById("heartbeatLabel");
chart_list=[];
chart_map=[];
widget_list=[];

// ===========  EVENTS =============

const ws = new WebSocket("ws://127.0.0.1:8000/ws/live");
ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);

  if (msg.type === "comp") {
      console.log("comp",msg)
      if (msg.widget.type =="chart")
      {
         addCandleWidget(msg.id, msg.widget.pair,msg.widget.timeframe,msg.widget.plot_config, msg.rect )
      }
      
  }
  else if (msg.type === "del") {
      
       const chartObj = chart_list[msg["id"]];
       console.log("del",msg,chartObj)
        chartObj.widget_ele.classList.add('closing');
        setTimeout(() => grid.removeWidget(chartObj.widget_ele), 200);
       
  }
  else if (msg.type === "candle") {
    //console.log("ðŸ•¯ï¸ nuova candle", msg);
    const id = msg.id;
    const pair = msg.pair;
    const chartObj = chart_list[id];

    if (!chartObj) {
        console.warn("Grafico non trovato per", pair);
        return;
    }
    const c = msg.data;
    //console.log("update" ,c)
    chartObj.mainSeries.update({
        //time: Math.floor(c.timestamp / 1000), // âš ï¸ seconds
        time: db_localTime(c.t),
        open: c.o,
        high: c.h,
        low: c.l,
        close: c.c,
        volume:c.v,
    });
    chartObj.volumeSeries.update({
        time: db_localTime(c.t),
        value: c.bv,
        color: c.c >= c.o ? '#4bffb5aa' : '#ff4976aa'
    });
  }
  else if (msg.type === "heartbeat") {
        const d = new Date(msg.ts);
        heartbeatLabel.textContent = d.toLocaleString();
  }
};
 $(document).ready(function () {
    
  fetch(`/api/layout/select`)
    .then(r => r.json())
    .then(data => {
      //alert(data)
    });
  });

// =============== GRID SETUP ==============================

const grid = GridStack.init({ 
    draggable: { handle: '.grid-stack-handle'},
    resizable: { handles: "e, se, s" },
    float:true 
});

function saveLayout() {
   const layout = grid.save(false); // false = senza DOM
   if (layout.length !=widget_list.length )
   {
     alert("ATTENZIONE LEN WINDGET");
      return;
   }

   //alert(widget_list.length);
   save=[]
  for(i=0;i<widget_list.length;i++)
  {
     save.push({"id": widget_list[i].id, "rect": layout[i],"data": widget_list[i].save()}) 
    
  }

  console.log(save)
  fetch(`/api/layout/save`,
  {
    method: 'POST', 
    headers: { 'Content-Type': 'application/json'},
    body:  JSON.stringify(save)
  }).then(response => {
        if (!response.ok) {
            throw new Error(`Errore HTTP! Stato: ${response.status}`);
        }
    });
  
  //localStorage.setItem("grid-layout", JSON.stringify(layout));
}

grid.on("change", saveLayout);

grid.on("resizestop", (e, el) => {
  const container = el.querySelector(".chart-container");
  if (!container) return;

  const chartObj = chart_list[container.id];
  if (!chartObj) return;

  console.log(chartObj);

  for(i=0;i<chartObj.charts.length;i++)
    {
        if (i==0)
            chartObj.charts[0].resize(
                container.clientWidth,
                container.clientHeight
            );
            else
             chartObj.charts[i].resize(
                container.clientWidth,
                100
            );
    }
});

// =============== CHART ===============


function createChart(widget_ele,id_chart,id_chart_vol, pair, timeframe,plot_config) {
    const container = document.getElementById(id_chart);
    console.log("container",container)
    const chart = LightweightCharts.createChart(container, {
        layout: {
            background: { color: '#253248' },
            textColor: 'rgba(255, 255, 255, 0.9)',
        },
        grid: {
            vertLines: { color: '#334158' },
            horzLines: { color: '#334158' },
        },
        crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
            // Vertical crosshair line (showing Date in Label)
            vertLine: {
                width: 1,
                color: '#C3BCDB44',
                style: LightweightCharts.LineStyle.Solid,
                labelBackgroundColor: '#9B7DFF',
            },

            // Horizontal crosshair line (showing Price in Label)
            horzLine: {
                height: 1,
                color: '#9B7DFF',
                labelBackgroundColor: '#9B7DFF',
            },
        },
        priceScale: { borderColor: '#485c7b' },
        timeScale: { borderColor: '#485c7b' },
        timeScale: {
            timeVisible: true,
            secondsVisible: false,
            borderColor: '#485c7b',
        },
    });

 
    const mainSeries = chart.addSeries(
        LightweightCharts.CandlestickSeries,
        {
            upColor: '#4bffb5',
            downColor: '#ff4976',
            borderUpColor: '#4bffb5',
            borderDownColor: '#ff4976',
            wickUpColor: '#838ca1',
            wickDownColor: '#838ca1',
        }
    );

    
    const chart2 = LightweightCharts.createChart(
        document.getElementById(id_chart),
        {
            height: 100,
            layout: {
                background: {
                    type: 'solid',
                    color: '#F5F5FF',
                },
            },
         timeScale: {
            timeVisible: true,
            secondsVisible: false,
            borderColor: '#485c7b',
        },
        }
    );

    const volumeSeries = chart2.addSeries(
        LightweightCharts.HistogramSeries,
        {
            priceFormat: {
                type: 'volume',
            },
            priceScaleId: '', // ðŸ‘ˆ scale separata sotto
            scaleMargins: {
            top: 0.7,
            bottom: 0,
            },
        }
        );

    // INDICATORS
    indicators = []

    Object.entries(plot_config["main_plot"]).forEach(([key, value]) => {
        console.log("ADD" , key, value);
        if (key == "ema")
        {
           indicators[key] = {
              fun : calculateEMA,
              args : value["eta"],
              series : chart.addSeries(
                LightweightCharts.LineSeries,
                {
                    color: '#4bffb5',
                    lineWidth: 1,
                }
              )
          }
        }
        
    });

    // SYNC

    chart.timeScale().subscribeVisibleLogicalRangeChange(timeRange => {
        chart2.timeScale().setVisibleLogicalRange(timeRange);
    });

    chart2.timeScale().subscribeVisibleLogicalRangeChange(timeRange => {
        chart.timeScale().setVisibleLogicalRange(timeRange);
    });

    
    function getCrosshairDataPoint(series, param) {
        if (!param.time) {
            return null;
        }
        const dataPoint = param.seriesData.get(series);
        return dataPoint || null;
    }

    function syncCrosshair(chart, series, dataPoint) {
        if (dataPoint) {
            chart.setCrosshairPosition(dataPoint.value, dataPoint.time, series);
            return;
        }
        chart.clearCrosshairPosition();
    }
    chart.subscribeCrosshairMove(param => {
        const dataPoint = getCrosshairDataPoint(mainSeries, param);
        syncCrosshair(chart2, volumeSeries, dataPoint);
    });
    chart2.subscribeCrosshairMove(param => {
        const dataPoint = getCrosshairDataPoint(volumeSeries, param);
        syncCrosshair(chart, mainSeries, dataPoint);
    });

    // final

      function refresh()
      {
        //console.log("....",this);
          fetch(`/api/ohlc_chart?pair=${this.pair}&timeframe=${this.timeframe}`)
            .then(r => r.json())
            .then(data => {
                //console.log(data)
               if (data.length>0)
               {
                  this.mainSeries.setData(
                      data.map(d => ({
                      time: db_localTime(d.t),
                      open: d.o,
                      high: d.h,
                      low: d.l,
                      close: d.c
                      }))
                  );
                  this.volumeSeries.setData(
                      data.map(d => ({
                          time: db_localTime(d.t),
                          value: d.bv,
                          color: d.c >= d.o ? '#4bffb5aa' : '#ff4976aa'
                      }))
                  );

                  Object.entries(this.indicators).forEach(([key, chartMeta]) => {
                      console.log("REFRESH", key, chartMeta);

                      const ind_data = chartMeta["fun"]( data, chartMeta["args"]);
                      console.log(ind_data)
                      chartMeta["series"].setData(ind_data);
                  });
                }
            });
      }
      function save()
      {
        //alert("save");
        return {"pair":pair,"timeframe":this.timeframe,"plot_config": this.plot_config}
      }

    chart_list[id_chart] = { id : id_chart, widget_ele:widget_ele, pair:pair, timeframe:timeframe, charts:[chart,chart2], mainSeries ,volumeSeries: volumeSeries, 
      plot_config:plot_config, indicators : indicators, refresh: refresh , save:save};

    chart_map[pair] = chart_list[id_chart] ;
    widget_list.push(chart_list[id_chart]);

    //console.log("!!!!!!!!!!",widget_list);
    // EXTRA

    /**
     * Funzione di utilitÃ  per convertire una coordinata Y in prezzo.
     * @param {number} yCoordinate - La coordinata Y in pixel relativa al riquadro del grafico.
     * @returns {number|null} Il prezzo corrispondente.
     */
    function convertCoordinateToPrice(yCoordinate) {
        if (mainSeries) {
            return mainSeries.coordinateToPrice(yCoordinate); 
        }
        return null;
    }

    container.addEventListener('contextmenu', function(event) {
      event.preventDefault(); // Impedisce la comparsa del menu contestuale del browser

      // Qui devi convertire le coordinate, vedi il punto 2
      const clientX = event.clientX;
      const clientY = event.clientY;

      // Ottieni le coordinate relative al grafico
      const chartRect = container.getBoundingClientRect();
      const chartY = clientY - chartRect.top;
      
      // Converti la coordinata Y in prezzo
      // Chiama la funzione di conversione (vedi sotto)
      const priceAtMouse = convertCoordinateToPrice(chartY); 

      console.log(`Evento Tasto Destro a coordinata Y del grafico: ${chartY}`);
      console.log(`Prezzo corrispondente: ${priceAtMouse}`);

      // Logica per mostrare il tuo menu contestuale al clientX/clientY

     
  });

 chart_list[id_chart] .refresh();
}


// ============== WIDGETS ===========================

function layout_closeWidget(item,id)
{
  //console.log("id",id)
  if (confirm('Chiudere il widget?')) {
    //#item.classList.add('closing');
    //setTimeout(() => grid.removeWidget(item), 200);
     fetch(`/api/layout/cmd`,
    {
      method: 'POST', 
      headers: { 'Content-Type': 'application/json'},
      body:  JSON.stringify({"scope" : "layout" , "cmd" :"del" , "id" : id})
    }).then(response => {
          if (!response.ok) {
              throw new Error(`Errore HTTP! Stato: ${response.status}`);
          }
      });
  }
}

function layout_addWidget(data)
{
  data.scope="layout"
  data.cmd="add"
  fetch(`/api/layout/cmd`,
  {
    method: 'POST', 
    headers: { 'Content-Type': 'application/json'},
    body:  JSON.stringify(data)
  }).then(response => {
        if (!response.ok) {
            throw new Error(`Errore HTTP! Stato: ${response.status}`);
        }
    });
}



function addWidget(title, contentHtml,rect) {
  const el = document.createElement('div');
  el.classList.add("grid-stack-item");
  el.innerHTML = `
    <div class="grid-stack-item-content">
      <h3 class="drag-handle">${title}</h3>
      <div class="no-drag">
            ${contentHtml}
        </div>
    </div>
  `;
    /*
  el.innerHTML1 = `
    <div class="grid-stack-item">
      <div class="grid-stack-item-content">
        <h3 class="drag-handle">${title}</h3>
        <div class="no-drag">
            ${contentHtml}
        </div>
      </div>
    </div>`;
    */
  grid.addWidget(el,rect);
}

function addTopVolume() {
  const id = "table_" + Date.now();
  addWidget("Top Volume", `<table id="${id}" class="display"></table>`);

  fetch('/api/top_volume')
    .then(r => r.json())
    .then(data => {
      $(`#${id}`).DataTable({
        data,
        columns: [
          { title:"Pair", data:"pair" },
          { title:"Volume", data:"volume" }
        ]
      });
    });
}

function addOHLC() {
  const pair = prompt("Pair (BTC/USDC):", "BTC/USDC");
  const tf = prompt("Timeframe:", "5m");
  const id = "ohlc_" + Date.now();

  addWidget(`OHLC ${pair} ${tf}`, `<table id="${id}" class="display"></table>`);

  fetch(`/api/ohlc?pair=${pair}&timeframe=${tf}`)
    .then(r => r.json())
    .then(data => {
      $(`#${id}`).DataTable({
        data,
        columns: [
          { title:"Time", data:"datetime" },
          { title:"Open", data:"open" },
          { title:"High", data:"high" },
          { title:"Low", data:"low" },
          { title:"Close", data:"close" },
          { title:"Volume", data:"quote_volume" }
        ]
      });
    });
}



function addCandleWidget(id, pair,timeframe,plot_config,rect) {

  console.log("plot_config",plot_config)
  function updateChartTimeframe(chartId, newTimeframe) {
    chatObj = chart_list[chartId]
    console.log(`Aggiornamento del grafico ID: ${chartId} al timeframe: ${newTimeframe} chatObj ${chatObj}`);
    chatObj.timeframe = newTimeframe;
    chatObj.refresh();
  }

  function attachTimeframeListener(widgetElement) {
    const selectElement = widgetElement.querySelector('.timeframe-selector');
    const chartContainer = widgetElement.querySelector('.chart-container');
    const chartId = chartContainer ? chartContainer.id : null;

    if (selectElement && chartId) {
        selectElement.addEventListener('change', (event) => {
            const newTimeframe = event.target.value;
            updateChartTimeframe(chartId, newTimeframe);
        });
        
        // Impedisci al click sulla tendina di attivare la funzione di drag di GridStack
        selectElement.addEventListener('mousedown', (event) => {
             event.stopPropagation();
        });
    }
 }

  const id_chart = id;//"chart_" + Date.now();
  const id_chart_vol = id+"_vol";//chart_vol_" + Date.now();

  const el = document.createElement("div");
  el.classList.add("grid-stack-item");

  el.innerHTML = `
    <div class="grid-stack-item-content">
     
      <div class="header  grid-stack-handle">
        <div class="header-title">
             ðŸ“ˆ ${pair} 
        </div>
        
        <select class="timeframe-selector" >
            <option value="1m">1m</option>
            <option value="5m">5m</option>
            <option value="15m" selected>15m</option> <option value="30m">30m</option>
            <option value="1h">1h</option>
            <option value="4h">4h</option>
            <option value="1d">1d</option>
        </select>
      <button class="close-btn" title="Chiudi" onclick="layout_closeWidget(this.closest('.grid-stack-item'),'${id_chart}')" >âœ•</button>
        
        
    </div>
      <div class="chart-container" id="${id_chart}"></div>
      <div class="chart-volume" id="${id_chart_vol}"></div>
    </div>
  `;
  if (rect==null)  rect =  { w: 6, h: 5 }

  grid.addWidget(el, rect  );

  el.querySelector('.timeframe-selector').value = timeframe;
  attachTimeframeListener(el);


  //createChart(id, pair, timeframe);
  setTimeout(() => {
    createChart(el,id_chart,id_chart_vol, pair, timeframe, plot_config);
    }, 0);
}

</script>

</body>
</html>